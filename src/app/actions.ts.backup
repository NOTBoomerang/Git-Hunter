"use server"
import axios from "axios";
import pLimit from "p-limit"; // npm i p-limit
import { ChatOpenAI } from "@langchain/openai";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { JsonOutputParser } from "@langchain/core/output_parsers";

/**
 * High-ROI defaults (override via env)
 */
const GITHUB_API = process.env.NEXT_GITHUB_API || "https://api.github.com";
const GITHUB_TOKEN = process.env.NEXT_GITHUB_TOKEN || "";
const OPENAI_KEY = process.env.NEXT_OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini"; // dynamic model choice via env
const MAX_FILE_SIZE = Number(process.env.MAX_FILE_SIZE_BYTES || 1024 * 1024); // 1MB
const MAX_FILES = Number(process.env.MAX_FILES || 100);
const BATCH_DOWNLOAD_CONCURRENCY = Number(process.env.BATCH_DOWNLOAD_CONCURRENCY || 6);
const LINES_PER_CHUNK = Number(process.env.LINES_PER_CHUNK || 200); // chunk files so models can reason with line ranges

/* ----------------------------
   Types
   ---------------------------- */
export type CodeSnippet = {
  name: string;
  content: string;
  language: string;
  path: string;
  size?: number;
  isOpen?: boolean;
  isLoading?: boolean;
  isSecure?: boolean;
  message?: string;
};

export type Vulnerability = {
  severity: "low" | "medium" | "high";
  title: string;
  description: string;
  file: string;
  startLine?: number;
  endLine?: number;
  fix: string; // suggested corrected code or patch snippet
  confidence?: number; // optional score 0-1
};

export type ScanResult = {
  file: string;
  vulnerabilities: Vulnerability[];
};

export type VulnerabilityCardContentType = {
  riskLevel: "low" | "medium" | "high" | "";
  riskTitle: string;
  riskDescription: string;
};

export type SemgrepFinding = {
  file: string;
  line: number;
  issue: string;
  severity: string;
  rule_id: string;
  cwe: string;
  owasp: string;
  description: string;
  secure_code_fix: string;
  original_message: string;
};

/* ----------------------------
   Enhanced Semgrep + AI Analysis Integration
   ---------------------------- */
export async function runSemgrepAnalysis(repoPath: string): Promise<SemgrepFinding[]> {
  try {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    console.log(`üîç Running enhanced Semgrep analysis on ${repoPath}...`);
    
    // Execute the Python Semgrep scanner
    const pythonScript = `${process.cwd()}/semgrep_scanner.py`;
    const { stdout, stderr } = await execAsync(`python3 ${pythonScript} ${repoPath}`, {
      timeout: 120000, // 2 minute timeout
      maxBuffer: 10 * 1024 * 1024, // 10MB buffer
    });
    
    if (stderr && !stderr.includes('DeprecationWarning')) {
      console.warn('Semgrep warnings:', stderr);
    }
    
    // Parse the JSON output
    const lines = stdout.split('\n');
    let jsonStart = -1;
    
    // Find where JSON array starts
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith('[')) {
        jsonStart = i;
        break;
      }
    }
    
    if (jsonStart === -1) {
      console.log('No JSON output found from Semgrep scanner');
      return [];
    }
    
    const jsonOutput = lines.slice(jsonStart).join('\n');
    const findings: SemgrepFinding[] = JSON.parse(jsonOutput);
    
    console.log(`‚úÖ Semgrep analysis complete. Found ${findings.length} enhanced findings.`);
    return findings;
    
  } catch (error: any) {
    console.error('Error running Semgrep analysis:', error.message);
    
    // Fallback to basic analysis if Semgrep fails
    console.log('Falling back to basic regex analysis...');
    return [];
  }
}

/* ----------------------------
   Utility: quick regex pre-scan (cheap & fast ‚Äî high ROI)
   ---------------------------- */
const DEFAULT_PATTERNS: { id: string; re: RegExp; severity: Vulnerability["severity"]; hint?: string }[] = [
  { id: "hardcoded_secrets", re: /(API_KEY|SECRET|PASSWORD|TOKEN)\s*[:=]\s*["']?[A-Za-z0-9_\-]{6,}["']?/i, severity: "high", hint: "hardcoded_secrets" },
  { id: "sql_string_interp", re: /SELECT.*FROM.*WHERE.*\$\{.*\}/i, severity: "high", hint: "sql_string_interp" },
  { id: "eval_os_system", re: /\beval\s*\(|\bos\.system\s*\(|\bsystem\(/i, severity: "high", hint: "eval_os_system" },
  { id: "weak_hash", re: /\b(md5|sha1)\s*\(/i, severity: "medium", hint: "weak_hash" },
  { id: "path_traversal", re: /\.\.\/|\.\.\\|open\([^,]*\+|fs\.readFileSync\([^,]*\+/, severity: "medium", hint: "path_traversal" },
];
      
      // Create temporary directory with files for Semgrep to scan
      const fs = await import('fs');
      const path = await import('path');
      const os = await import('os');
      
      const tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'semgrep-scan-'));
      
      try {
        // Write files to temp directory
        for (const snippet of snippets) {
          const filePath = path.join(tempDir, snippet.name);
          const fileDir = path.dirname(filePath);
          
          // Create directory if it doesn't exist
          await fs.promises.mkdir(fileDir, { recursive: true });
          await fs.promises.writeFile(filePath, snippet.content);
        }
        
        // Run Semgrep analysis
        const semgrepFindings = await runSemgrepAnalysis(tempDir);
        
        // Convert Semgrep findings to ScanResult format
        const fileResults: ScanResult[] = [];
        const groupedFindings: Record<string, Vulnerability[]> = {};
        
        for (const finding of semgrepFindings) {
          const vulnerability: Vulnerability = {
            severity: finding.severity.toLowerCase() as "low" | "medium" | "high",
            title: finding.issue.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            description: finding.description,
            file: finding.file.replace(tempDir, '').replace(/^\//, ''),
            startLine: finding.line,
            endLine: finding.line,
            fix: finding.secure_code_fix,
            confidence: 0.9 // Higher confidence for Semgrep + AI analysis
          };
          
          const fileName = vulnerability.file;
          if (!groupedFindings[fileName]) {
            groupedFindings[fileName] = [];
          }
          groupedFindings[fileName].push(vulnerability);
        }
        
        // Convert to ScanResult format
        for (const [file, vulnerabilities] of Object.entries(groupedFindings)) {
          fileResults.push({ file, vulnerabilities });
        }
        
        console.log(`‚úÖ Enhanced analysis found ${semgrepFindings.length} issues across ${fileResults.length} files`);
        return fileResults;
        
      } finally {
        // Clean up temp directory
        await fs.promises.rm(tempDir, { recursive: true, force: true });
      }
      
    } catch (error) {
      console.error('Enhanced analysis failed, falling back to basic scan:', error);
      // Fall through to basic analysis
    }
  }
  
  // Pre-scan all files quickly (regex) - fallback or basic mode
  const quickFindsPromises = snippets.map(async (s) => ({ file: s.name, quick: await cheapPreScan(s) }));
  const quickFinds = await Promise.all(quickFindsPromises);/**
 * High-ROI defaults (override via env)
 */
const GITHUB_API = process.env.NEXT_GITHUB_API || "https://api.github.com";
const GITHUB_TOKEN = process.env.NEXT_GITHUB_TOKEN || "";
const OPENAI_KEY = process.env.NEXT_OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini"; // dynamic model choice via env
const MAX_FILE_SIZE = Number(process.env.MAX_FILE_SIZE_BYTES || 1024 * 1024); // 1MB
const MAX_FILES = Number(process.env.MAX_FILES || 100);
const BATCH_DOWNLOAD_CONCURRENCY = Number(process.env.BATCH_DOWNLOAD_CONCURRENCY || 6);
const LINES_PER_CHUNK = Number(process.env.LINES_PER_CHUNK || 200); // chunk files so models can reason with line ranges

/* ----------------------------
   Types
   ---------------------------- */
export type CodeSnippet = {
  name: string;
  content: string;
  language: string;
  path: string;
  size?: number;
  isOpen?: boolean;
  isLoading?: boolean;
  isSecure?: boolean;
  message?: string;
};

export type Vulnerability = {
  severity: "low" | "medium" | "high";
  title: string;
  description: string;
  file: string;
  startLine?: number;
  endLine?: number;
  fix: string; // suggested corrected code or patch snippet
  confidence?: number; // optional score 0-1
};

export type ScanResult = {
  file: string;
  vulnerabilities: Vulnerability[];
};

export type VulnerabilityCardContentType = {
  riskLevel: "low" | "medium" | "high" | "";
  riskTitle: string;
  riskDescription: string;
};

/* ----------------------------
   Utility: quick regex pre-scan (cheap & fast ‚Äî high ROI)
   ---------------------------- */
const DEFAULT_PATTERNS: { id: string; re: RegExp; severity: Vulnerability["severity"]; hint?: string }[] = [
  { id: "hardcoded_secrets", re: /(API_KEY|SECRET|PASSWORD|TOKEN)\s*[:=]\s*["']?[A-Za-z0-9_\-]{6,}["']?/i, severity: "high", hint: "hardcoded_secrets" },
  { id: "sql_string_interp", re: /SELECT.*FROM.*WHERE.*\$\{.*\}/i, severity: "high", hint: "sql_string_interp" },
  { id: "eval_os_system", re: /\beval\s*\(|\bos\.system\s*\(|\bsystem\(/i, severity: "high", hint: "eval_os_system" },
  { id: "weak_hash", re: /\b(md5|sha1)\s*\(/i, severity: "medium", hint: "weak_hash" },
  { id: "path_traversal", re: /\.\.\/|\.\.\\|open\([^,]*\+|fs\.readFileSync\([^,]*\+/, severity: "medium", hint: "path_traversal" },
];

/* ----------------------------
   fetchRepoFiles: uses git/trees for a single recursive listing
   ---------------------------- */
export async function fetchRepoFiles(owner: string, repo: string, branch = "main"): Promise<CodeSnippet[]> {
  if (!GITHUB_TOKEN) {
    console.warn("‚ö†Ô∏è NO GITHUB TOKEN ‚Äî returning demo files (for hackathon).");
    // Return demo data like your earlier snippet ‚Äî compact set for demo
    return [
      {
        name: "server.js",
        path: "server.js",
        content: `const express = require('express');\nconst app = express();\n// insecure sample...`,
        language: "js",
        size: 512,
      },
    ];
  }

  // Step 1: get the SHA of the branch
  const branchResp = await axios.get(`${GITHUB_API}/repos/${owner}/${repo}/branches/${branch}`, {
    headers: { Authorization: `token ${GITHUB_TOKEN}`, Accept: "application/vnd.github.v3+json" },
    timeout: 10000,
  }).catch((e: any) => {
    throw new Error(`Failed to fetch branch ${branch}: ${e?.response?.status || e.message}`);
  });

  const commitSha = branchResp.data?.commit?.commit?.tree?.sha || branchResp.data?.commit?.sha;
  if (!commitSha) {
    throw new Error("Could not locate branch commit SHA.");
  }

  // Step 2: get a recursive tree (single call)
  const treeResp = await axios.get(`${GITHUB_API}/repos/${owner}/${repo}/git/trees/${commitSha}?recursive=1`, {
    headers: { Authorization: `token ${GITHUB_TOKEN}`, Accept: "application/vnd.github.v3+json" },
    timeout: 20000,
  });

  const items: any[] = treeResp.data?.tree || [];
  // Filtering logic (extensions, ignore patterns)
  const ALLOWED_EXT = /\.(js|ts|py|java|php|rb|go|rs|jsx|tsx|mjs|cjs|env|config|conf|ini|xml|yaml|yml|json|md|txt)$/i;
  const IGNORED_PATHS = [/node_modules/, /\.gitignore/, /package-lock\.json/, /^dist\//, /^build\//, /\.DS_Store/];

  const candidates = items
    .filter((it) => it.type === "blob")
    .filter((it) => ALLOWED_EXT.test(it.path) || /\.env$/i.test(it.path) || /config/i.test(it.path))
    .filter((it) => !IGNORED_PATHS.some((r) => r.test(it.path)))
    .slice(0, MAX_FILES);

  // Step 3: download files in limited concurrency
  const limit = pLimit(BATCH_DOWNLOAD_CONCURRENCY);
  const downloads = candidates.map((it) =>
    limit(async (): Promise<CodeSnippet | null> => {
      try {
        // skip huge blobs
        if (it.size > MAX_FILE_SIZE) {
          console.warn(`Skipping large file ${it.path} size=${it.size}`);
          return null;
        }
        // use raw URL pattern to download
        const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${it.path}`;
        const resp = await axios.get<string>(rawUrl, { timeout: 15000, responseType: "text", transformResponse: [(v: any) => v] });
        return {
          name: it.path,
          path: it.path,
          content: resp.data,
          language: it.path.split(".").pop()?.toLowerCase() || "txt",
          size: it.size,
        };
      } catch (err: any) {
        console.warn(`Failed to fetch ${it.path}: ${err?.message || err}`);
        return null;
      }
    })
  );

  const results = await Promise.all(downloads);
  const final = results.filter(Boolean) as CodeSnippet[];
  console.log(`Fetched ${final.length} files from ${owner}/${repo}`);
  return final;
}

/* ----------------------------
   chunkFileIntoRanges: split large files into chunks with line numbers
   ---------------------------- */
function chunkFileIntoRanges(snippet: CodeSnippet, linesPerChunk = LINES_PER_CHUNK) {
  const lines = snippet.content.split(/\r?\n/);
  const chunks: { text: string; startLine: number; endLine: number; file: string }[] = [];
  for (let i = 0; i < lines.length; i += linesPerChunk) {
    const start = i + 1;
    const end = Math.min(i + linesPerChunk, lines.length);
    const text = lines.slice(i, end).join("\n");
    chunks.push({ text, startLine: start, endLine: end, file: snippet.name });
  }
  return chunks;
}

/* ----------------------------
   cheapPreScan: runs regex scans and returns quick findings.
   Very high ROI: catch obvious low-hanging fruit locally before calling LLM.
   ---------------------------- */
export async function cheapPreScan(snippet: CodeSnippet) {
  const matches: Vulnerability[] = [];
  const titleMap: Record<string, string> = {
    "hardcoded_secrets": "Hardcoded Secrets Detected",
    "sql_string_interp": "SQL Injection Vulnerability", 
    "eval_os_system": "Code Injection Risk",
    "weak_hash": "Weak Cryptographic Hash",
    "path_traversal": "Path Traversal Vulnerability"
  };
  
  for (const pat of DEFAULT_PATTERNS) {
    if (pat.re.test(snippet.content)) {
      matches.push({
        severity: pat.severity,
        title: pat.hint || pat.id,
        description: titleMap[pat.hint || pat.id] || `Security issue detected: ${pat.id}`,
        file: snippet.name,
        startLine: 1,
        endLine: 1,
        fix: getQuickFix(pat.hint || pat.id),
        confidence: 0.8,
      });
    }
  }
  return matches;
}

function getQuickFix(patternId: string): string {
  const fixes: Record<string, string> = {
    "hardcoded_secrets": "Move secrets to environment variables using process.env.SECRET_NAME",
    "sql_string_interp": "Use parameterized queries or prepared statements instead of string concatenation",
    "eval_os_system": "Replace eval() and system() calls with safer alternatives that don't execute arbitrary code",
    "weak_hash": "Use SHA-256, SHA-3, or bcrypt instead of MD5/SHA1 for cryptographic operations",
    "path_traversal": "Validate and sanitize file paths, use path.resolve() and restrict to safe directories"
  };
  
  return fixes[patternId] || "Review and secure this code pattern";
}

/* ----------------------------
   LLM analysis piece: analyze a single chunk and return vulnerabilities array
   Uses LangChain ChatOpenAI and JsonOutputParser for robust parsing.
   ---------------------------- */
const modelPromptTemplate = `You are a security-focused code auditor.
Input:
- {chunkText}
- FILE: {file}
- LINES: {startLine}-{endLine}

Task: Return a JSON object with "vulnerabilities": an array of objects with:
- severity: "low"|"medium"|"high"
- title: short
- description: concise explanation
- startLine: number (absolute in file)
- endLine: number
- fix: minimal code snippet or mitigation steps
Do not output any extra text.`;

type LlmOutput = { vulnerabilities: Vulnerability[] };

async function analyzeChunkWithModel(chunkText: string, file: string, startLine: number, endLine: number): Promise<Vulnerability[]> {
  if (!OPENAI_KEY) {
    // fallback
    return [];
  }

  const model = new ChatOpenAI({
    model: OPENAI_MODEL,
    temperature: 0,
    openAIApiKey: OPENAI_KEY,
  });

  const parser = new JsonOutputParser<LlmOutput>();

  const prompt = ChatPromptTemplate.fromTemplate(modelPromptTemplate);

  // chain-style invocation (LangChain simplified)
  try {
    const chain = prompt.pipe(model).pipe(parser);
    const response = await chain.invoke({ chunkText, file, startLine: startLine.toString(), endLine: endLine.toString() });
    // parser returns typed output
    // Response may have vulnerabilities array
    if (response?.vulnerabilities) return response.vulnerabilities.map((v: any) => ({ ...v, file }));
    return [];
  } catch (err: any) {
    console.warn("LLM analyze failed:", err?.message || err);
    return [];
  }
}

/* ----------------------------
   scanRepo: orchestrates pre-scan -> model-scan only for flagged files (cost-savings)
   Returns ScanResult[] for each file
   ---------------------------- */
export async function scanRepoFiles(snippets: CodeSnippet[]): Promise<ScanResult[]> {
  // Pre-scan all files quickly (regex)
  const quickFindsPromises = snippets.map(async (s) => ({ file: s.path, quick: await cheapPreScan(s) }));
  const quickFinds = await Promise.all(quickFindsPromises);

  // Files needing LLM: those with quickFinds OR matching certain types (e.g., .js/.py)
  const candidates = snippets.filter((s) => {
    const q = quickFinds.find((x) => x.file === s.path);
    if (q && q.quick.length > 0) return true; // flagged
    // also consider code files by extension
    return /\.(js|ts|py|java|php|go|rb)$/i.test(s.name);
  });

  // Limit concurrency for LLM calls
  const limit = pLimit(3);
  const fileResults: ScanResult[] = [];

  // For each candidate, chunk and analyze (but only call model on chunk if pre-scan matched in that chunk)
  for (const snippet of candidates) {
    const fileQuick = quickFinds.find((x) => x.file === snippet.path)?.quick || [];
    const chunked = chunkFileIntoRanges(snippet);

    // For each chunk, run a quick regex check to decide whether to call LLM
    const chunkPromises = chunked.map((c) =>
      limit(async () => {
        // cheap test: regex on the chunk
        let callLLM = DEFAULT_PATTERNS.some((p) => p.re.test(c.text));
        // also call model for new/important languages always (configurable)
        if (!callLLM && /\.(js|ts|py|java)$/i.test(snippet.name)) {
          // optional heuristic: call model only on first chunk to limit token usage
          callLLM = c.startLine === 1;
        }

        // Always collect quickFinds mapped to file-level findings
        // If we will call LLM:
        if (callLLM && OPENAI_KEY) {
          const vv = await analyzeChunkWithModel(c.text, c.file, c.startLine, c.endLine);
          return vv;
        } else {
          // If not calling LLM, but pre-scan found something in file-level, return those mapped to this file
          if (fileQuick.length > 0) {
            return fileQuick;
          }
          return [];
        }
      })
    );

    const chunkVulnsArrays = await Promise.all(chunkPromises);
    // flatten & dedupe
    const vulnerabilities = ([] as Vulnerability[]).concat(...chunkVulnsArrays).filter(Boolean);
    fileResults.push({ file: snippet.name, vulnerabilities });
  }

  // Add non-candidate files with only cheap pre-scan hits
  const nonCandidates = snippets.filter((s) => !candidates.includes(s));
  for (const s of nonCandidates) {
    const quick = await cheapPreScan(s);
    if (quick.length > 0) fileResults.push({ file: s.name, vulnerabilities: quick });
  }

  return fileResults;
}

/* ----------------------------
   Enhanced Semgrep + AI Analysis Integration
   ---------------------------- */
export async function runSemgrepAnalysis(repoPath: string): Promise<SemgrepFinding[]> {
  try {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    console.log(`üîç Running enhanced Semgrep analysis on ${repoPath}...`);
    
    // Execute the Python Semgrep scanner
    const pythonScript = `${process.cwd()}/semgrep_scanner.py`;
    const { stdout, stderr } = await execAsync(`python3 ${pythonScript} ${repoPath}`, {
      timeout: 120000, // 2 minute timeout
      maxBuffer: 10 * 1024 * 1024, // 10MB buffer
    });
    
    if (stderr && !stderr.includes('DeprecationWarning')) {
      console.warn('Semgrep warnings:', stderr);
    }
    
    // Parse the JSON output
    const lines = stdout.split('\n');
    let jsonStart = -1;
    
    // Find where JSON array starts
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith('[')) {
        jsonStart = i;
        break;
      }
    }
    
    if (jsonStart === -1) {
      console.log('No JSON output found from Semgrep scanner');
      return [];
    }
    
    const jsonOutput = lines.slice(jsonStart).join('\n');
    const findings: SemgrepFinding[] = JSON.parse(jsonOutput);
    
    console.log(`‚úÖ Semgrep analysis complete. Found ${findings.length} enhanced findings.`);
    return findings;
    
  } catch (error: any) {
    console.error('Error running Semgrep analysis:', error.message);
    
    // Fallback to basic analysis if Semgrep fails
    console.log('Falling back to basic regex analysis...');
    return [];
  }
}

export type SemgrepFinding = {
  file: string;
  line: number;
  issue: string;
  severity: string;
  rule_id: string;
  cwe: string;
  owasp: string;
  description: string;
  secure_code_fix: string;
  original_message: string;
};

/* ----------------------------
   Legacy compatibility functions for existing UI
   ---------------------------- */
export async function checkCodeSecurity(code: string): Promise<{ 
  isSecure: boolean; 
  vulnerabilities: Vulnerability[] 
}> {
  const snippet: CodeSnippet = {
    name: "input.js",
    path: "input.js",
    content: code,
    language: "javascript",
    size: code.length
  };
  
  const vulnerabilities = await cheapPreScan(snippet);
  return {
    isSecure: vulnerabilities.length === 0,
    vulnerabilities
  };
}

export async function scanVulnerability(code: string): Promise<VulnerabilityCardContentType & { correctCode: string }> {
  const snippet: CodeSnippet = {
    name: "temp.js",
    path: "temp.js", 
    content: code,
    language: "javascript",
    size: code.length
  };
  
  const vulnerabilities = await cheapPreScan(snippet);
  
  if (vulnerabilities.length === 0) {
    return {
      riskLevel: "low",
      riskTitle: "No Issues Found", 
      riskDescription: "The code appears to be secure based on our analysis.",
      correctCode: code // Return original code if no issues
    };
  }
  
  const highestSeverity = vulnerabilities.reduce((highest, curr) => {
    const severityOrder = { low: 1, medium: 2, high: 3 };
    return severityOrder[curr.severity] > severityOrder[highest.severity] ? curr : highest;
  });
  
  // Generate better descriptions and secure code fixes
  const secureCodeFix = generateSecureCodeFix(code, highestSeverity);
  
  return {
    riskLevel: highestSeverity.severity,
    riskTitle: highestSeverity.title,
    riskDescription: getDetailedDescription(highestSeverity, code),
    correctCode: secureCodeFix
  };
}

function getDetailedDescription(vulnerability: Vulnerability, originalCode: string): string {
  const descriptions: Record<string, string> = {
    "hardcoded_secrets": `This code contains hardcoded sensitive information (API keys, passwords, tokens, or secrets) directly in the source code. This is a critical security vulnerability because:

‚Ä¢ Secrets are visible to anyone with access to the code
‚Ä¢ Version control systems store these secrets permanently
‚Ä¢ Deployed applications expose secrets in plain text
‚Ä¢ Attackers can extract and misuse these credentials

The detected pattern suggests sensitive data is embedded directly in the code rather than being loaded from secure environment variables or a secrets management system.`,

    "sql_string_interp": `This code uses string interpolation to build SQL queries, making it vulnerable to SQL injection attacks. This occurs when user input is directly concatenated into SQL statements without proper sanitization:

‚Ä¢ Attackers can inject malicious SQL code through input parameters
‚Ä¢ Database contents can be read, modified, or deleted
‚Ä¢ Administrative access to the database may be compromised
‚Ä¢ Application logic can be bypassed

The vulnerability allows attackers to manipulate the SQL query structure by providing specially crafted input values.`,

    "eval_os_system": `This code uses dynamic code execution functions (eval, system, exec) which can lead to remote code execution vulnerabilities:

‚Ä¢ Attackers can execute arbitrary code on the server
‚Ä¢ System commands can be injected and executed
‚Ä¢ Full system compromise is possible
‚Ä¢ Application sandbox can be escaped

These functions should never process untrusted input as they interpret and execute the input as code or system commands.`,

    "weak_hash": `This code uses cryptographically weak hashing algorithms (MD5, SHA1) that are vulnerable to collision attacks and rainbow table lookups:

‚Ä¢ MD5 and SHA1 are considered broken for security purposes
‚Ä¢ Modern hardware can compute billions of hashes per second
‚Ä¢ Precomputed hash tables (rainbow tables) exist for common inputs
‚Ä¢ Collisions can be generated with reasonable computational effort

For security-sensitive applications, use stronger algorithms like SHA-256, SHA-3, or bcrypt for password hashing.`,

    "path_traversal": `This code appears to be vulnerable to path traversal attacks, where attackers can access files outside the intended directory:

‚Ä¢ Users can provide paths with "../" sequences to navigate up directories
‚Ä¢ Sensitive system files may be accessible
‚Ä¢ Application configuration files could be exposed
‚Ä¢ The vulnerability can lead to information disclosure or code execution

File operations should validate and sanitize all path inputs to prevent directory traversal.`
  };

  return descriptions[vulnerability.title] || vulnerability.description;
}

function generateSecureCodeFix(originalCode: string, vulnerability: Vulnerability): string {
  const fixes: Record<string, (code: string) => string> = {
    "hardcoded_secrets": (code: string) => {
      // Replace hardcoded secrets with environment variables
      let fixedCode = code;
      
      // Common patterns and their secure replacements
      const patterns = [
        { pattern: /(API_KEY|SECRET|PASSWORD|TOKEN)\s*[:=]\s*["']([^"']+)["']/gi, 
          replacement: '$1 = process.env.$1 || ""' },
        { pattern: /apiKey\s*[:=]\s*["']([^"']+)["']/gi, 
          replacement: 'apiKey = process.env.API_KEY || ""' },
        { pattern: /password\s*[:=]\s*["']([^"']+)["']/gi, 
          replacement: 'password = process.env.PASSWORD || ""' }
      ];
      
      patterns.forEach(({ pattern, replacement }) => {
        fixedCode = fixedCode.replace(pattern, replacement);
      });
      
      // Add environment variable loading if not present
      if (!fixedCode.includes('require("dotenv")') && !fixedCode.includes('import dotenv')) {
        fixedCode = 'require("dotenv").config();\n\n' + fixedCode;
      }
      
      return `// ‚úÖ Secure version - uses environment variables
${fixedCode}

// Add to your .env file:
// API_KEY=your_actual_api_key_here
// PASSWORD=your_actual_password_here`;
    },

    "sql_string_interp": (code: string) => {
      let fixedCode = code;
      
      // Replace string interpolation with parameterized queries
      fixedCode = fixedCode.replace(
        /SELECT.*FROM.*WHERE.*\$\{.*\}/gi,
        'SELECT * FROM users WHERE id = ?'
      );
      
      return `// ‚úÖ Secure version - uses parameterized queries
${fixedCode}

// Example with proper parameterization:
// const query = 'SELECT * FROM users WHERE id = ? AND name = ?';
// const results = await db.query(query, [userId, userName]);
// 
// Never use: 'SELECT * FROM users WHERE id = ' + userId
// Always use: parameterized queries or prepared statements`;
    },

    "eval_os_system": (code: string) => {
      let fixedCode = code;
      
      // Remove dangerous eval/system calls
      fixedCode = fixedCode.replace(/eval\s*\([^)]+\)/gi, '// eval() removed - use safer alternatives');
      fixedCode = fixedCode.replace(/os\.system\s*\([^)]+\)/gi, '// os.system() removed - use subprocess with validation');
      fixedCode = fixedCode.replace(/system\s*\([^)]+\)/gi, '// system() removed - use safer alternatives');
      
      return `// ‚úÖ Secure version - removes dynamic code execution
${fixedCode}

// Safe alternatives:
// - Instead of eval(): use JSON.parse() for data, or a proper parser
// - Instead of system(): use child_process.spawn() with input validation
// - Validate and sanitize all inputs
// - Use allowlists for permitted operations`;
    },

    "weak_hash": (code: string) => {
      let fixedCode = code;
      
      // Replace weak hashing with strong alternatives
      fixedCode = fixedCode.replace(/md5\s*\(/gi, 'crypto.createHash("sha256")');
      fixedCode = fixedCode.replace(/sha1\s*\(/gi, 'crypto.createHash("sha256")');
      
      return `// ‚úÖ Secure version - uses strong hashing
const crypto = require('crypto');
${fixedCode}

// For password hashing, use bcrypt:
// const bcrypt = require('bcrypt');
// const hashedPassword = await bcrypt.hash(password, 12);
// const isValid = await bcrypt.compare(inputPassword, hashedPassword);`;
    },

    "path_traversal": (code: string) => {
      let fixedCode = code;
      
      // Add path validation
      fixedCode = fixedCode.replace(
        /(open\s*\(|fs\.readFileSync\s*\(|readFile\s*\()[^,)]+/gi,
        '$1path.resolve(SAFE_DIR, path.basename(filename))'
      );
      
      return `// ‚úÖ Secure version - validates file paths
const path = require('path');
const SAFE_DIR = '/safe/directory'; // Define your safe directory

${fixedCode}

// Additional security measures:
// - Use path.resolve() and path.basename() to sanitize paths  
// - Define an allowed directory and never go outside it
// - Validate file extensions with an allowlist
// - Check if resolved path starts with your safe directory`;
    }
  };

  const fixFunction = fixes[vulnerability.title];
  if (fixFunction) {
    return fixFunction(originalCode);
  }
  
  return `// ‚úÖ Secure version
${originalCode}

// General security recommendations:
// - Validate and sanitize all inputs
// - Use environment variables for secrets
// - Apply principle of least privilege
// - Keep dependencies updated`;
}

/* ----------------------------
   Example server handler usage (Next.js / Express)
   High-ROI: minimal wrapper to call fetchRepoFiles + scanRepoFiles then return
   ---------------------------- */
export async function handleScanRequest(req: any, res: any) {
  try {
    const { owner, repo, branch } = req.body || req.query;
    if (!owner || !repo) return res.status(400).json({ error: "owner & repo required" });

    const files = await fetchRepoFiles(owner, repo, branch || "main");
    // Very high ROI: short-circuit if no files
    if (!files.length) return res.status(200).json({ results: [] });

    const results = await scanRepoFiles(files);
    return res.status(200).json({ results, scannedFiles: files.length });
  } catch (err: any) {
    console.error("scan error:", err?.message || err);
    return res.status(500).json({ error: err?.message || "scan failed" });
  }
}
